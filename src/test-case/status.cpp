/* Test cases for the status line handlers.
 *
 * HTTP prefaces server headers with a status line. There's a few functions to
 * look up and otherwise deal with those in the code, and this file tests them.
 *
 * See also:
 * * Project Documentation: https://ef.gy/documentation/cxxhttp
 * * Project Source Code: https://github.com/ef-gy/cxxhttp
 * * Licence Terms: https://github.com/ef-gy/cxxhttp/blob/master/COPYING
 *
 * @copyright
 * This file is part of the cxxhttp project, which is released as open source
 * under the terms of an MIT/X11-style licence, described in the COPYING file.
 */

#include <cxxhttp/http-status.h>
#include <ef.gy/test-case.h>

using namespace cxxhttp;

/* Test status description lookup.
 * @log Test output stream.
 *
 * Performs a few lookups, including deliberately invalid status codes, to make
 * sure that works as expected.
 *
 * @return 'true' on success, 'false' otherwise.
 */
bool testDescription(std::ostream &log) {
  struct sampleData {
    unsigned in;
    std::string out;
  };

  std::vector<sampleData> tests{
      {0, "Other Status"},
      {100, "Continue"},
      {404, "Not Found"},
  };

  for (const auto &tt : tests) {
    const auto v = http::statusLine::getDescription(tt.in);
    if (v != tt.out) {
      log << "http::statusLine::getDescription(" << tt.in << ")='" << v
          << "', expected '" << tt.out << "'\n";
      return false;
    }
  }

  return true;
}

/* Test status parsing.
 * @log Test output stream.
 *
 * Parses some status lines to see if that works as expected.
 *
 * @return 'true' on success, 'false' otherwise.
 */
bool testParse(std::ostream &log) {
  struct sampleData {
    std::string in;
    bool valid;
    unsigned code;
    std::string protocol, description;
  };

  std::vector<sampleData> tests{
      {"", false, 0, "", ""},
      {"frob", false, 0, "", ""},
      {"HTTP/1.1 glorb", false, 0, "", ""},
      {"HTTP/1.1 555 glorb\r", true, 555, "HTTP/1.1", "glorb"},
      {"HTTP/1.1 999 glorb\r", false, 999, "HTTP/1.1", "glorb"},
      {"HTTP/1.0 200 OK", true, 200, "HTTP/1.0", "OK"},
  };

  for (const auto &tt : tests) {
    const http::statusLine v(tt.in);
    if (v.valid() != tt.valid) {
      log << "http::statusLine(" << tt.in << ") has incorrect result\n";
      return false;
    }
    if (v.valid()) {
      if (v.code != tt.code) {
        log << "http::statusLine(" << tt.in << ").code='" << v.code
            << "', expected'" << tt.code << "'\n";
        return false;
      }
      if (v.protocol() != tt.protocol) {
        log << "http::statusLine(" << tt.in << ").protocol='" << v.protocol()
            << "', expected'" << tt.protocol << "'\n";
        return false;
      }
      if (v.description != tt.description) {
        log << "http::statusLine(" << tt.in << ").description='"
            << v.description << "', expected'" << tt.description << "'\n";
        return false;
      }
    }
  }

  return true;
}

/* Test header generation.
 * @log Test output stream.
 *
 * Generates a few status lines, including incorrect ones, to make sure no
 * un-parseable lines are generated by us.
 *
 * @return 'true' on success, 'false' otherwise.
 */
bool testGenerate(std::ostream &log) {
  struct sampleData {
    std::string in;
    bool valid;
    unsigned code;
    std::string protocol, description, out;
  };

  std::vector<sampleData> tests{
      {"", false, 0, "HTTP/0.0", "", "HTTP/1.1 500 Bad Status Line\r\n"},
      {"frob", false, 0, "HTTP/0.0", "", "HTTP/1.1 500 Bad Status Line\r\n"},
      {"HTTP/1.1 glorb", false, 0, "HTTP/0.0", "",
       "HTTP/1.1 500 Bad Status Line\r\n"},
      {"HTTP/1.1 555 glorb\r", true, 555, "HTTP/1.1", "glorb",
       "HTTP/1.1 555 glorb\r\n"},
      {"HTTP/1.1 999 glorb\r", false, 999, "HTTP/1.1", "glorb",
       "HTTP/1.1 500 Bad Status Line\r\n"},
      {"HTTP/1.0 200 OK", true, 200, "HTTP/1.0", "OK", "HTTP/1.0 200 OK\r\n"},
      {"HTTP/1.0 666 OK", false, 666, "HTTP/1.0", "OK",
       "HTTP/1.1 500 Bad Status Line\r\n"},
  };

  for (const auto &tt : tests) {
    const http::statusLine v(tt.in);
    if (v.valid() != tt.valid) {
      log << "http::statusLine(" << tt.in << ") has incorrect result\n";
      return false;
    }
    if (v.code != tt.code) {
      log << "http::statusLine(" << tt.in << ").code='" << v.code
          << "', expected'" << tt.code << "'\n";
      return false;
    }
    if (v.protocol() != tt.protocol) {
      log << "http::statusLine(" << tt.in << ").protocol='" << v.protocol()
          << "', expected'" << tt.protocol << "'\n";
      return false;
    }
    if (v.description != tt.description) {
      log << "http::statusLine(" << tt.in << ").description='" << v.description
          << "', expected'" << tt.description << "'\n";
      return false;
    }
    if (std::string(v) != tt.out) {
      log << "http::statusLine(" << tt.in << ").out='" << std::string(v)
          << "', expected'" << tt.out << "'\n";
      return false;
    }
  }

  return true;
}

namespace test {
using efgy::test::function;

static function description(testDescription);
static function parse(testParse);
static function generate(testGenerate);
}  // namespace test
